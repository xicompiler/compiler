program ::= use* definitions

interface ::= signature+

use ::= USE ID SEMICOLON?

definitions ::= globdecl SEMICOLON? definitions | fn loption(definitions)

globdecl ::= decl | assign

decl ::= ID COLON TYPE

assign ::= assignee GETS expr

assignee ::= ID | decl

fn ::= signature block

signature ::= ID LPAREN args RPAREN loption(types)

args ::= separated_list(decl, COMMA)

types ::= COLON separated_nonempty_list(type, COMMA)

type ::= TYPE | type LBRACKET RBRACKET

block ::= LBRACE list(stmt) return? RBRACE

return ::= RETURN expr? SEMICOLON?

stmt ::= if | while | single_stmt SEMICOLON? | block

if ::= IF expr stmt else?

else ::= ELSE stmt

while ::= WHILE expr stmt

single_stmt ::= decl | assign | multi_init | app

multi_init ::= separated_list(multi_assignee, COMMA) GETS app

multi_assignee ::= decl | WILDCARD

app ::= ID LPAREN separated_list(expr, COMMA) RPAREN

expr ::= expr binop bop_expr | bop_expr

bop_expr ::= unop uop_expr | uop_expr

uop_expr ::= 
  | uop_expr LBRACKET expr BRACKET
  | app
  | LPAREN expr RPAREN
  | INT
  | BOOL
  | LBRACE loption(array) RBRACE

array ::= separated_nonempty_list(expr, COMMA) COMMA?

binop ::=
  | OR | AND
  | EQ | NEQ
  | LT | LEQ | GEQ | GT
  | PLUS | MINUS
  | MULT | HIGHMULT | DIV | MOD

unop ::= MINUS | NOT
